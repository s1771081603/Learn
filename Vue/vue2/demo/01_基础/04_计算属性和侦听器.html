<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>计算属性和侦听器</title>
  <script src="../vue.js"></script>
</head>
<body>
  <div id="root">
    <h2>计算属性和方法</h2>
    <p>
      我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。<br>
      然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。<br>
      这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。<br><br>
      Original message: "{{ message }}"<br>
      Methods Reversed Message: "{{ reversedMessageOne() }}"<br>
      Computed Reversed Message: "{{ reversedMessageTwo }}"<br>
      {{now}}<br>
      {{fullNames}}<br>
    </p><br>
  </div>
  <script>
    let vm = new Vue({
      el: '#root',
      data(){
        return{
          message: 'hello vue!',
          firstName: 'cailu',
          lastName: 'songlisheng',
          fullName: '',
        }
      },
      watch:{
        firstName(val){
          this.fullName = val + ' ' + this.lastName
        },
        lastName(val){
          this.fullName = this.firstName + ' ' + val
        }
      },
      methods: {
        reversedMessageOne(){
          console.log("methods");
          return this.message.split('').reverse().join('')
        }
      },
      computed: {
        reversedMessageTwo(){
          console.log("computed");
          return this.message.split('').reverse().join('')
        },
        now(){
          return Date.now()
        },
        fullNames: {
          // getter
          get: function() {
            return this.firstName + ' ' + this.lastName
          },
          // setter
          set: function(newValue) {
            var names = newValue.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length - 1]
            console.log(this.firstName,this.lastName);
          }
        }
      }
    })
  </script>
</body>
</html>