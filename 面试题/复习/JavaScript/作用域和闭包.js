// 相信绝大多数同学都听过闭包这个概念，但闭包具体是什么估计很少有人能够说的很详细。
// 说实话闭包在我们平时开发中应该是很常见的，并且在前端面试中闭包也是常见的重要考点，
// 在学习闭包之前我们先来看看作用域与作用域链，因为这是闭包的关键。

/**
 * 作用域
 *
 * 简单来说，作用域是只程序中定义变量的区域，他决定了当前执行代码对变量的访问权限。
 * 在 ES5 中，一般只有两种作用域类型：
 *      全局中用域：全局作用域作为程序的最外层作用域，一直存在。
 *      函数作用域：函数作用域只在函数被定义时才会创建，包含在父级函数作用域或全局作用域中。
 *
 * 说完概念，我们来看下面这段代码：
 *      var a = 100
 *      function test(){
 *          var b = a * 2
 *          var a = 200
 *          var c = a/2
 *          console.log(b)
 *          console.log(c)
 *      }
 *      test()      // 这里会打印出什么？
 *
 *      解析：
 *          1.首先这段代码形成了全局作用域与函数作用域。
 *          2.全局作用域有一个变量 a 赋值为100。
 *          3.在 test 函数作用域中定义了局部变量 b , a , c。
 *          4.这里又存在变量提升，在函数作用域内先进行变量提升 var b; var a; var c;
 *          5.再对 b 进行赋值，这时候 a 还没有被赋值，所以 a 的值为 undefined，再将 a * 2 ，所以 b 为 NaN。
 *          6.再给 a 赋值为 200，c 赋值为 a / 2 等于 100
 *          [所以最终会打印出 NaN，100]
 *
 * 在 ES6 中，新增了一种 【块级作用域】
 *      简单来说，花括号 {...} 内的区域就是块级作用域，但 JavaScript 并不是原生支持块级作用域的，
 *      需要借助 ES6 提出的 let、const 来创建块级作用域。
 *
 *      // ES5
 *      if(true) {
 *          var name = '南玖'
 *      }
 *      console.log(name)  // 南玖
 *
 *      // ES6
 *      if(true) {
 *          let age = 18
 *      }
 *      console.log(age)  // 这里会报错
 *
 * 作用域链
 *      当可执行代码内部访问变量时，会先查找当前作用域下有无该变量，有则返回，
 *      没有的话则会去父级作用域中查找...一直找到全局作用域。我们把这种作用域的嵌套机制称为 作用域链。
 *
 * 词法作用域
 *      词法作用域是作用域的一种工作模式，词法作用域是 JavaScript 中使用的一种作用域类型，
 *      此法作用域也可以被叫做 静态作用域。
 *
 * 所谓的词法作用域就是在你写代码时将变量和作用域写在哪里来决定的，也就是词法作用域是静态的作用域，在你写代码时就决定了。
 * 【函数作用域取决于它申明的位置，与实际调用的位置无关】
 * */

/**
 * MDN 对闭包的定义
 *      一个函数和对其周围（语法环境）的引用捆绑在一起或者说函数被引用包围，这样的组合就是闭包。
 *      我们可以得出：闭包 = 函数 + 外层作用域
 *
 *      var name = '前端南玖'
 *      function say() {
 *          console.log(name)
 *      }
 *      say()
 *
 *      解析：say 函数可以访问到外层作用域的变量 a，那么这样不就是形成了一个闭包吗？
 *      在《JavaScript权威指南》书中有这样一句话：【严格来讲，所有 JavaScript 函数都是闭包】
 *      但这只是理论上的闭包，与我们平时使用的不太一样。上面这个例子只是一个简单的闭包。
 *
 * ECMA 对闭包的定义
 *      从理论上来讲：所有的函数都是闭包。因为他们在创建的时候就已经上层上下文的数据保存起来了。
 *      从实践来讲：闭包应该满足两个条件。
 *          1、在代码中引用了外层作用域的变量。
 *          2、及时创建它的上下文已经销毁，它仍然存在。
 *
 *      let scope = 'global scope'
 *      function checkScope(){
 *          let scope = 'local scope'
 *          function f(){
 *              return scope
 *          }
 *          return f
 *      }
 *
 *      let s = checkScope()
 *      s() // 这里返回什么？
 *
 *      解析：
 *          1、首先执行全局代码，创建全局执行上下文，定义全局变量 scope 并赋值。
 *          2、申明 checkScope 函数，并创建该函数的执行上下文，创建局部变量 scope 并赋值。
 *          3、申明 f 函数，创建该函数的执行上下文。
 *          4、执行 checkScope 函数，该函数又返回了一个 f 函数赋值给了变量 s。
 *          5、执行 s 函数，相当于执行了 f 函数。这里返回的 scope 是 'local scope'。
 *              至于为什么是 local scope ，我们上面讲到了词法作用的基本规则：JavaScript 函数是使用定义他们的作用域来执行的。
 *              在定义 f 函数的作用域中，变量 scope 的值为 local scope。
 * */

/**
 * 闭包的应用
 *      绝大多都是在维护内部变量的场景下使用。
 *
 * 闭包的缺陷
 *      1、由于闭包的村子可能会造成变量常驻内存，使用不当会造成内存泄漏。
 *      2、内存泄漏可能会导致应用程序卡顿或者崩溃。
 * 高频闭包面试题
 *      var arr = []
 *      for(var i = 0; i < 3; i++){
 *          arr[i] = function(){
 *              console.log(i)
 *          }
 *      }
 *      arr[0]()  // 3
 *      arr[1]()  // 3
 *      arr[2]()  // 3
 *      // 这里在执行的时候i已经变成了3
 *
 *      // 使用闭包解决
 *      var arr = []
 *      for(var i = 0; i < 3 ; i++){
 *          arr[i] = (function(i){
 *              return function(){
 *                  console.log(i)
 *              }
 *          })(i)
 *      }
 *      arr[0]() // 0
 *      arr[1]() // 1
 *      arr[2]() // 2
 * */